我们可以知道函数的this是在被调用时绑定的，也就是说this完全取决于函数的调用位置。

调用位置在哪里
这里的调用位置是指函数在代码中被调用的位置，不是声明的位置。该调用位置是在当前正在执行的函数的前一个调用中。我们可以借助浏览器的开发者工具进行理解。如图1
01.png

图1
在上图中，在run函数中插入debugger使运行暂停，此时Call Stack就是当前位置的函数调用列表，也就是所说的调用栈。在栈中的第二个元素，就是要找的调用位置。

绑定规则及其优先级
在找到调用位置后，还需要应用规则来判断this的绑定对象，这些规则也有优先级之分，优先级从高到低如图2。
02.PNG
优先级从高到低
图2

规则一 new绑定
new是可以影响函数调用时this绑定行为的方法，这里也称做new绑定。
在使用new调用函数时，会执行以下4个过程。
第一个过程：创建一个全新的对象。
第二个过程：将新对象的原型绑定到函数的原型上。
第三个过程：将新对象绑定到函数调用的this。
第四个过程：如果函数没有返回其他对象，则返回这个新对象。

规则二 显式绑定
显式绑定是指使用call(…)或apply(…)直接指定this的绑定对象。当然，bind(…)这种强制绑定（硬绑定）也是显式绑定中的一种，它会把参数设置为this的上下文并返回一个新的函数。

规则三 隐式绑定
这条规则是看调用位置是否有上下文，或者是否被某个对象拥有或包含。在对象属性引用链中，只有最外层会影响调用位置。
当然，隐式绑定存在隐式丢失的情况，这是就改应用默认绑定了，从而把this绑定到全局对象上。如果函数体处于严格模式下，默认绑定的this则为undefined。
举例说明隐式丢失的情况。

function speak(){
    console.log(`说了${this.count}次`);
}
let obj = {
    count: 3,
    speak:speak
}
window.count = 4;
let p1 = obj.speak;
p1(); //说了4次
规则四 默认绑定
当函数执行时，是直接使用不带任何修饰的函数引用进行调用，无法应用其他规则，就称为默认绑定。

this绑定的例外
被忽略的this
可以使用null、undefined和Object.create(null)作为this的绑定对象传入call、apply或bind来忽略this的绑定。但null和undefined没有Object.create(null)安全，null和undefined会将绑定规则改为默认绑定，使this绑定到全局对象。

间接引用
间接引用应用的是默认绑定规则，这种情况最容易出现在赋值时。

软绑定
既能实现硬绑定的效果，又能保留隐式绑定或显式绑定修改this的能力的方法，称软绑定。

它会对指定的函数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或undefined，那就把指定的默认对象 obj 绑定到 this，否则不会修改 this。

箭头函数
箭头函数不使用this的四种规则，而是根据外层作用域来决定的。
箭头函数的this绑定后不会被修改，和new一样。
self = this和箭头函数可以取代this机制。
